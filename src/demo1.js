//generate combinations of rgb & hsv values in steps of 8
const getColorArray=()=>{
    let rgbValues=[];
    let hsvValues=[];
    //red values step of 8
    for (let red=8; red<=256; red+=8){
        //green values step of 8
        for (let green=8; green<=256; green+=8){
            //blue values step of 8
            for (let blue=8; blue<=256; blue+=8){
                //add to rgb array
                let rgbVal={r:red-1, g:green-1,b:blue-1}
                rgbValues.push(rgbVal);
                //convert to hsv
                let hsvVal=rgb2hsv(red-1,green-1,blue-1);
                //add to hsv array
                hsvValues.push(hsvVal);
            }
        }    
    }
    return([rgbValues,hsvValues]);
};

//sourced from the net - source forge: convert rgb to hsv values.
function rgb2hsv (r, g, b) {
    let rabs, gabs, babs, rr, gg, bb, h, s, v, diff, diffc, percentRoundFn;
    rabs = r / 255;
    gabs = g / 255;
    babs = b / 255;
    v = Math.max(rabs, gabs, babs);
    diff = v - Math.min(rabs, gabs, babs);
    diffc = c => (v - c) / 6 / diff + 1 / 2;
    percentRoundFn = num => Math.round(num * 100) / 100;
    if (diff == 0) {
        h = s = 0;
    } else {
        s = diff / v;
        rr = diffc(rabs);
        gg = diffc(gabs);
        bb = diffc(babs);

        if (rabs === v) {
            h = bb - gg;
        } else if (gabs === v) {
            h = (1 / 3) + rr - bb;
        } else if (babs === v) {
            h = (2 / 3) + gg - rr;
        }
        if (h < 0) {
            h += 1;
        }else if (h > 1) {
            h -= 1;
        }
    }
    return {
        h: Math.round(h * 360),
        s: percentRoundFn(s * 100),
        v: percentRoundFn(v * 100)
    };
}//end rgb2hsv

//get all hues in the array of colors
const getHueValueRange=(hsvValueArray)=>{
    let hueValues=[];
    //process all colors in the input array
    hsvValueArray.forEach(hsvVal=>{
        // check if return array already has value, if not add it
        if (!hueValues.includes(hsvVal.h)){
            hueValues.push(hsvVal.h);
        }
    });
    //sort the return values in the array
    hueValues=hueValues.sort((a,b)=>a-b);
    return(hueValues);
};

//get all values in the array of colors
const getValValueRange=(hsvValueArray)=>{
    let valValues=[];
    //process all colors in the input array
    hsvValueArray.forEach(hsvVal=>{
        // check if return array already has value, if not add it
        if (!valValues.includes(hsvVal.v)){
            valValues.push(hsvVal.v);
        }
    });
    //sort the return values in the array
    valValues=valValues.sort((a,b)=>a-b);
    return(valValues);
};

//get all saturations in the array of colors
const getSatValueRange=(hsvValueArray)=>{
    let satValues=[];
    //process all colors in the input array
    hsvValueArray.forEach(hsvVal=>{
        // check if return array already has value, if not add it
        if (!satValues.includes(hsvVal.s)){
            satValues.push(hsvVal.s);
        }
    });
    //sort the return values in the array
    satValues=satValues.sort((a,b)=>a-b);
    return(satValues);
};

const randomValue = (start,multiplier) => Math.floor((Math.random()+start)*multiplier);


const getImageCellMatrix = () => {
    //colors is an array of arrays which stores colors in two arrays of [0]rgb values and [1]hsv values
    //generated by combining different rgb values
    let colorsHSV=getColorArray()[1];
    //variable for row height
    let height=5;
    //varibale for cell width
    let width=5;
    //cell count for debugging
    let cellCount=0;
    // start a new array which will store each row of image
    let rows=[];
    //start a variable to count all rows
    let rowCount=0;
    // add an initial item to rows
    rows.push({
        row: rowCount,
        rowItemCount:0,
        rowHieght:height,
        cells:[]
    });
    // start a variable to keep row items in check
    let rowItemCount=0;
    // get all hue values in the colors array 
    let hues=getHueValueRange(colorsHSV);
    //Process all hues
    while (hues.length>0){
        //set a current hue
        let currentHue=hues.shift();
        //get all colors with the current hue
        let hueColors=colorsHSV.filter(item=>item.h===currentHue);
        //get all value vals associated with this hue
        let vals=getValValueRange(hueColors);
        // process all value vals associated with this hue
        while (vals.length>0){
            //set a current value associated with this hue
            let currentValue=vals.shift();
            //get all colors with this hue and value
            let valColors=colorsHSV.filter(item=>item.h===currentHue&&item.v===currentValue);
            //get all saturation values associated with this hue and value
            let sats=getSatValueRange(valColors);
            //sort this sats array in descending order
            sats=sats.reverse();
            //process all saturation values associated with this hue and value
            while (sats.length>0){
                let currentSat=sats.shift();
                //there should be only one color with this hue, value and saturation, get it
                let cellColor=colorsHSV.filter(item=>item.h===currentHue&&item.v===currentValue&&item.s===currentSat)[0];
                //add this to the rows
                //first check to see if there is room in this row
                if (rowItemCount===128){
                    //row is full start a new row
                    rowCount++;
                    rows.push({
                        row: rowCount,
                        rowItemCount:0,
                        rowHieght:height,
                        cells:[]
                    });
                    rowItemCount=0;
                }
                //add the cellColor to the cols array of the current row
                rows[rowCount].cells.push({
                    cellColor:cellColor,
                    cellWidth:width
                });
                //increase rowItemCount by 1
                rowItemCount++;
                rows[rowCount].rowItemCount = rowItemCount;                
                //remove this color from the original colorHSV array
                //get index of color to remove
                let index = colorsHSV.findIndex(item=>item.h===currentHue&&item.v===currentValue&&item.s===currentSat);
                //splice the array
                colorsHSV.splice(index,1);
                //cell count 
                cellCount++;
                //console.log(`Cell Count: ${cellCount}, H:${cellColor.h},S:${cellColor.s},V:${cellColor.v}`);
            }//end process all saturation values (for current hue and value)
        }//end process all values (for current hue)
    }//end process all hues  
    //console.log(`No of rows: ${rows.length}`);
    return(rows);
}

let matrix = getImageCellMatrix();
console.log('done');



